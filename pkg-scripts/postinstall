#!/bin/bash

if [ -z "$1" ]; then
    echo "Error: Full path not provided."
    exit 1
fi

full_path="$1"
base_path=$(dirname "$full_path")
output_file="$base_path/log.txt"
completion_file="$base_path/done.txt"

if [ -e "$output_file" ]; then
    rm "$output_file"
fi

script_code_1="set endFile to \"$completion_file\""
script_code_2='
-- Bash script as a string
set bashScript to "if ! command -v brew &> /dev/null; then
    echo \"Homebrew is not installed. Installing Homebrew...\"
    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"
    '
script_code_3="(echo; echo 'eval \\\"\$(/opt/homebrew/bin/brew shellenv)\\\"') >> ~/.zprofile"
script_code_4='
    eval \"$(/opt/homebrew/bin/brew shellenv)\"
else
    echo \"Homebrew is already installed.\"
fi" & " && brew install libfido2" & " && touch " & endFile & " && exit"

tell application "Terminal"
	activate
	set shell to do script bashScript
end tell

-- Check for the existence of the completion file
repeat while not (do shell script "[ -e \"" & endFile & "\" ] && echo 1 || echo 0") is equal to "1"
	delay 1
end repeat
return "Done"'
real_script="$script_code_1$script_code_2$script_code_3$script_code_4"

# Current folder
pwd > "$output_file"

# Full path to the pkg
echo "Run pkg from: $1" >> "$output_file"

# Full path to the installation destination. For example: /Applications
echo "Installation destination: $2" >> "$output_file"

osascript -e "$real_script" &
wait

app_resources_path="/Applications/Locker Password Manager.app/Contents/Resources"
binary_path="$app_resources_path/locker-service"
cert_path="$app_resources_path/cert"

### CREATE CERTS

cd "$cert_path"
rm *.pem
rm *.srl
rm *.cnf

# 1. Generate CA's private key and self-signed certificate
openssl req -x509 -newkey rsa:4096 -days 365 -nodes -keyout ca-key.pem -out ca-cert.pem -subj "/C=VN/ST=Hanoi/L=Hanoi/O=CyStack.JSC/ou=Enterprise/cn=*.cystack.net/emailaddress=contact@cystack.net"

echo "CA's self-signed certificate" >> "$output_file"
openssl x509 -in ca-cert.pem -noout -text

# 2. Generate web server's private key and certificate signing request (CSR)
openssl req -newkey rsa:4096 -nodes -keyout server-key.pem -out server-req.pem -subj "/C=FR/ST=Ile de France/L=Paris/O=Server tls/ou=server/cn=*.tls/emailaddress=tls@gmail.com"

# Remember that when we develop on localhost, Itâ€™s important to add the IP:0.tcp.in.ngrok.io as an Subject Alternative Name (SAN) extension to the certificate.
echo "subjectAltName=DNS:*.tls,DNS:localhost,IP:0.0.0.0" > server-ext.cnf
# Or you can use localhost DNS and grpc.ssl_target_name_override variable
# echo "subjectAltName=DNS:localhost" > server-ext.cnf

# 3. Use CA's private key to sign web server's CSR and get back the signed certificate
openssl x509 -req -in server-req.pem -days 60 -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile server-ext.cnf

echo "Server's signed certificate" >> "$output_file"
openssl x509 -in server-cert.pem -noout -text

# List of ports
ports=(14401 14100 15601 14402 16301 14504 14505 14403)

# Flag to track if any port responded
responded=false

# Iterate over each port
for port in "${ports[@]}"; do
    # Send a GET request to localhost:port/ping-locker-service
    response=$(curl -s "http://localhost:$port/ping-locker-service")

    # Check if the response contains "pong" (adjust as needed)
    if [[ "$response" == *"pong"* ]]; then
        responded=true
        break  # Exit the loop if any port responds
    fi
done

# Check if any port responded
if [ "$responded" = true ]; then
    echo "Service is currently running" >> "$output_file"
    sudo "$binary_path" -service=stop
    sudo "$binary_path" -service=uninstall
    echo "Current service is uninstalled" >> "$output_file"
else
    echo "Service is not running" >> "$output_file"
fi

sudo "$binary_path" -service=install
sudo "$binary_path" -service=start
echo "Service is started" >> "$output_file"

echo "end" >> "$output_file"

# rm $completion_file
if [ -e "$completion_file" ]; then
    rm "$completion_file"
fi

exit 0
